<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>patient_desktop_client</title>

    <!-- WinJS references -->
    <link href="//Microsoft.WinJS.2.0/css/ui-dark.css" rel="stylesheet" />
    <script src="//Microsoft.WinJS.2.0/js/base.js"></script>
    <script src="//Microsoft.WinJS.2.0/js/ui.js"></script>

    <!-- patient_desktop_client references -->
    <link href="/css/default.css" rel="stylesheet" />
    <script src="/js/default.js"></script>
</head>
<body>
    <h1 id="debug">Content goes here</h1>

    <script src="/js/three.min.js"></script>
    <script>
        // debug msg
        var msg = document.getElementById("debug");

        // Kinect set up
        var kinect = WindowsPreview.Kinect;
        var sensor = kinect.KinectSensor.getDefault();
        var bodyFrameReader = sensor.bodyFrameSource.openReader();
        bodyFrameReader.addEventListener("framearrived", readerBodyFrameArrived);
        var bodies = new Array(sensor.bodyFrameSource.bodyCount);
        sensor.open();

        // Set up scene
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Set up lighting
        scene.add(new THREE.AmbientLight(0xaaaaaa));
        var light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(0, 0, 1000);
        scene.add(light);

        // Set up model
        var mesh;

        // Load model
        var loader = new THREE.JSONLoader();
        loader.load("models/joker/joker.js", createModel);

        // Array of joints
        var joints;

        function readerBodyFrameArrived(args) {
            //msg.innerHTML = "body frame has arrived!";

            var bodyFrame = args.frameReference.acquireFrame();
            if (bodyFrame == null) {
                //msg.innerHTML = "there is no body in view!";
                return;
            }

            bodyFrame.getAndRefreshBodyData(bodies);
            bodyFrame.close();

            // find a tracked body and store its joint positions
            for (i = 0; i < bodies.length; i++) {
                if (bodies[i].isTracked) {
                    //msg.innerHTML = "body is being tracked!";
                    var kinectJoints = bodies[i].jointOrientations;
                    joints = new Array();
                    for (i = 0; i < kinectJoints.size; i++) {
                        var jointPosition = kinectJoints.lookup(i).orientation;
                        joints.push({ w: jointPosition.w, x: jointPosition.x, y: jointPosition.y, z: jointPosition.z });
                    }

                    break;
                } else {
                    //msg.innerHTML = "no body is being tracked!";
                }
            }
        }

        function createModel(geometry, materials) {
            msg.innerHTML = "Called create model.";

            for (i = 0; i < materials.length; i++) {
                materials[i].skinning = true;
            }

            mesh = new THREE.SkinnedMesh(geometry, new THREE.MeshFaceMaterial(materials));
            mesh.position.set(0, -2, -5);
            mesh.scale.set(1, 1, 1);

            for (i = 0; i < mesh.skeleton.bones.length; i++) {
                mesh.skeleton.bones[i].useQuaternion = false;
            }

            scene.add(mesh);
        }

        function render() {
            requestAnimationFrame(render);

            // map inner representation of joints to model bones
            if (mesh != null && joints != null) {
                msg.innerHTML = "Mapping joints to model.";
                
                // map kinect joints to model bones
                /*
                mapBoneToJoint(0, 0);
                mapBoneToJoint(1, 1);
                mapBoneToJoint(2, 20);
                mapBoneToJoint(3, 2);
                mapBoneToJoint(4, 2); // map unknown bone to neck
                mapBoneToJoint(5, 8);
                mapBoneToJoint(6, 9);
                mapBoneToJoint(7, 10);
                mapBoneToJoint(8, 4);
                mapBoneToJoint(9, 5);
                mapBoneToJoint(10, 6);
                mapBoneToJoint(11, 16);
                mapBoneToJoint(12, 17);
                mapBoneToJoint(13, 18);
                mapBoneToJoint(14, 19);
                mapBoneToJoint(15, 12);
                mapBoneToJoint(16, 15, 13);
                mapBoneToJoint(17, 14);
                mapBoneToJoint(18, 15);
                */

                mapBoneToJoint(7, 12);
                mapBoneToJoint(8, 13);
            } else {
                msg.innerHTML = "The joints array is empty!";
            }
            renderer.render(scene, camera);
        }
        render();

        function mapBoneToJoint(boneIndex, jointIndex) {
            mesh.skeleton.bones[boneIndex].quaternion.w = joints[jointIndex].w;
            mesh.skeleton.bones[boneIndex].quaternion.x = joints[jointIndex].x;
            mesh.skeleton.bones[boneIndex].quaternion.y = joints[jointIndex].y;
            mesh.skeleton.bones[boneIndex].quaternion.z = joints[jointIndex].z;
        }

    </script>
</body>
</html>
