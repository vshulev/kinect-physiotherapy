<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>patient_desktop_client</title>

    <!-- WinJS references -->
    <link href="//Microsoft.WinJS.2.0/css/ui-dark.css" rel="stylesheet" />
    <script src="//Microsoft.WinJS.2.0/js/base.js"></script>
    <script src="//Microsoft.WinJS.2.0/js/ui.js"></script>

    <!-- patient_desktop_client references -->
    <link href="/css/default.css" rel="stylesheet" />
    <script src="/js/default.js"></script>
    <script src="/js/kinect_data_extractor.js"></script>
</head>
<body>
    <h1 id="debug">Content goes here</h1>

    <script src="/js/three.min.js"></script>
    <script>
        // debug msg
        var msg = document.getElementById("debug");

        // Kinect set up
        var kinect = WindowsPreview.Kinect;
        var sensor = kinect.KinectSensor.getDefault();
        var bodyFrameReader = sensor.bodyFrameSource.openReader();
        bodyFrameReader.addEventListener("framearrived", readerBodyFrameArrived);
        var bodies = new Array(sensor.bodyFrameSource.bodyCount);
        sensor.open();

        // Set up scene
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Set up lighting
        scene.add(new THREE.AmbientLight(0xaaaaaa));
        var light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(0, 0, 1000);
        scene.add(light);

        // Set up model
        var mesh;

        // Load model
        var loader = new THREE.JSONLoader();
        loader.load("models/stan-lee/stan_lee.js", createModel);

        // Array of joints
        var joints;

        // Bone - Joint mapping
        // TODO change mapping legend to reflect actual mapping...
        // bones[0] - { 0 - Spine base, 1 - Spine mid }
        // bones[1] - { 1 - Spine mid, 20 - Spine shoulder }
        // bones[2] - { 20 - Spine shoulder, 2 - Neck }
        // bones[3] - { 2 - Neck, 3 - Head }
        // bones[4] - N/A
        // bones[5] - { 20 - Spine shoulder, 4 - Shoulder left }
        // bones[6] - { 4 - Shoulder left, 5 - Elbow left }
        // bones[7] - { 5 - Elbow left, 6 - Wrist left }
        // bones[8] - { 20 - Spine shoulder, 8 - Shoulder right }
        // bones[9] - { 8 - Shoulder right, 9 - Elbow right }
        // bones[10] - { 9 - Elbow right, 10 - Wrist right }
        // bones[11] - { 0 - Spine base, 12 - Hip left }
        // bones[12] - { 12 - Hip left, 13 - Knee left }
        // bones[13] - { 13 - Knee left, 14 - Ankle left }
        // bones[14] - { 14 - Ankle left, 15 - Foot left }
        // bones[15] - { 0 - Spine base, 16 - Hip right } 
        // bones[16] - { 16 - Hip right, 17 - Knee right }
        // bones[17] - { 17 - Knee right, 18 - Ankle right }
        // bones[18] - { 18 - Ankle right, 19 - Foot right }

        var mapping = [
            { start: 0, end: 1, child: 1 },      // 0
            { start: 1, end: 20, child: 2 },     // 1
            { start: 20, end: 2, child: 3 },     // 2
            { start: 2, end: 3, child: -1 },     // 3
            { start: -1, end: -1, child: -1 },   // 4 - this bone is a mistake, it should be removed
            { start: 20, end: 8, child: 6 },     // 5
            { start: 8, end: 9, child: 7 },      // 6
            { start: 9, end: 10, child: -1 },    // 7
            { start: 20, end: 4, child: 9 },     // 8
            { start: 4, end: 5, child: 10 },     // 9
            { start: 5, end: 6, child: -1 },     // 10
            { start: 0, end: 16, child: 12 },    // 11
            { start: 12, end: 13, child: 13 },   // 12
            { start: 16, end: 17, child: 14 },   // 13
            { start: 18, end: 19, child: -1 },   // 14
            { start: 0, end: 12, child: 16 },    // 15
            { start: 12, end: 13, child: 17 },   // 16
            { start: 13, end: 14, child: 18 },   // 17
            { start: 14, end: 15, child: -1 },   // 18
        ];

        function readerBodyFrameArrived(args) {
            //msg.innerHTML = "body frame has arrived!";

            var bodyFrame = args.frameReference.acquireFrame();
            if (bodyFrame == null) {
                //msg.innerHTML = "there is no body in view!";
                return;
            }

            bodyFrame.getAndRefreshBodyData(bodies);
            bodyFrame.close();

            // find a tracked body and store its joint positions
            for (i = 0; i < bodies.length; i++) {
                if (bodies[i].isTracked) {
                    //msg.innerHTML = "body is being tracked!";
                    var kinectJoints = bodies[i].joints;
                    joints = new Array();
                    for (i = 0; i < kinectJoints.size; i++) {
                        var jointPosition = kinectJoints.lookup(i).position;
                        joints.push({ x: jointPosition.x, y: jointPosition.y, z: jointPosition.z });
                    }

                    break;
                } else {
                    //msg.innerHTML = "no body is being tracked!";
                }
            }
        }

        function createModel(geometry, materials) {
            msg.innerHTML = "Called create model.";

            for (i = 0; i < materials.length; i++) {
                materials[i].skinning = true;
            }

            mesh = new THREE.SkinnedMesh(geometry, new THREE.MeshFaceMaterial(materials));
            mesh.position.set(0, -2, -5);
            mesh.scale.set(1, 1, 1);

            scene.add(mesh);

            // store direction vectors for each bone
            for (i = 0; i < mapping.length; i++) {
                var childIndex = mapping[i].child;
                if (childIndex == -1) {
                    mapping[i].dv = null;
                    continue;
                }

                // get the parent and child bones (a.k.a. the two joints at each bone's end)
                var parent = mesh.skeleton.bones[i];
                var child = mesh.skeleton.bones[childIndex];

                // get the GLOBAL positions of both bones (joints)
                var parentPos = getGlobalBonePosition(parent);
                var childPos = getGlobalBonePosition(child);

                // store the coordinates (keep in mind y an z are flipped?)
                var x1 = parentPos.x;
                var y1 = parentPos.y;
                var z1 = parentPos.z;

                var x2 = childPos.x;
                var y2 = childPos.y;
                var z2 = childPos.z;

                // caculate the direction vector that goes from start to end joint
                var initDv = getDirectionVector(new THREE.Vector3(x1, y1, z1), new THREE.Vector3(x2, y2, z2));
                initDv.normalize();

                mapping[i].dv = initDv;

                // save quaternion value just in case
                var q = mesh.skeleton.bones[i].quaternion;
                mapping[i].quat = new THREE.Quaternion(q.x, q.y, q.z, q.w);
            }

            //testMaTheory();
        }

        function testMaTheory() {
            var dv = mapping[6].dv;
            var tv = new THREE.Vector3(0, 1, 0);

            var translationVec = getGlobalBonePosition(mesh.skeleton.bones[6]);

            var dvTrans = new THREE.Vector3().addVectors(dv, translationVec);
            var tvTrans = new THREE.Vector3().addVectors(tv, translationVec);

            var dvLocal = mesh.skeleton.bones[6].worldToLocal(dvTrans);
            var tvLocal = mesh.skeleton.bones[6].worldToLocal(tvTrans);

            // working in local space from this point on
            var axis = new THREE.Vector3().crossVectors(dvLocal, tvLocal);
            axis.normalize();

            var angle = dvLocal.angleTo(tvLocal);

            mesh.skeleton.bones[6].rotateOnAxis(axis, angle);
        }

        // returns the global position of a given bone
        function getGlobalBonePosition(bone) {
            if (mesh == null) {
                return null;
            }
            return new THREE.Vector3().setFromMatrixPosition(bone.matrixWorld);
        }

        function getDirectionVector(vec1, vec2) {
            var res = new THREE.Vector3();
            res.subVectors(vec2, vec1);
            return res;
        }
        
        function render() {
            requestAnimationFrame(render);

            // map inner representation of joints to model bones
            if (mesh != null && joints != null) {
                //msg.innerHTML = "Mapping joints to model.";

                for (i = 6; i < 7/*mapping.length*/; i++) {
                    if (mapping[i].dv == null) {
                        continue; // do not rotate end bones
                    }

                    // get start and end joint (Kinect indices)
                    var sjIndex = mapping[i].start; // start joint index
                    var ejIndex = mapping[i].end; // end joint index

                    // avoid bone 4 which serves no function
                    if(sjIndex == -1) {
                        continue;
                    }

                    var startJoint = joints[sjIndex];
                    var endJoint = joints[ejIndex];

                    // calculate target vector
                    var tv = getDirectionVector(
                        new THREE.Vector3(startJoint.x, startJoint.y, -startJoint.z),
                        new THREE.Vector3(endJoint.x, endJoint.y, -endJoint.z));
                    tv.normalize();

                    // translate dv and tv
                    var translationVec = getGlobalBonePosition(mesh.skeleton.bones[i]);

                    var dvTrans = new THREE.Vector3().addVectors(mapping[i].dv, translationVec);
                    var tvTrans = new THREE.Vector3().addVectors(tv, translationVec);

                    // convert world vectors to local vectors
                    var dvLocal = mesh.skeleton.bones[i].worldToLocal(dvTrans);
                    var tvLocal = mesh.skeleton.bones[i].worldToLocal(tvTrans);

                    // get rotation axis
                    var axis = new THREE.Vector3().crossVectors(dvLocal, tvLocal);
                    axis.normalize();

                    // get rotation angle
                    var angle = dvLocal.angleTo(tvLocal);

                    // apply rotation
                    mesh.skeleton.bones[i].rotateOnAxis(axis, angle);

                    // update direction vector
                    mapping[i].dv = tv;

                    // calculate angle at left elbow
                    var dv1 = getDirectionVector(
                        new THREE.Vector3(joints[5].x, joints[5].y, joints[5].z),
                        new THREE.Vector3(joints[6].x, joints[6].y, joints[6].z)
                        );

                    var dv2 = getDirectionVector(
                        new THREE.Vector3(joints[5].x, joints[5].y, joints[5].z),
                        new THREE.Vector3(joints[4].x, joints[4].y, joints[4].z)
                    );

                    var angleRad = dv1.angleTo(dv2);
                    var angleDeg = angleRad * (180 / Math.PI);

                    msg.innerHTML = "Angle is " + angleDeg;
                }
            } else {
                msg.innerHTML = "The joints array is empty!";
            }

            renderer.render(scene, camera);
        }
        render();

    </script>
</body>
</html>
