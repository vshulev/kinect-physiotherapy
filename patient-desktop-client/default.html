<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>patient_desktop_client</title>

    <!-- WinJS references -->
    <link href="//Microsoft.WinJS.2.0/css/ui-dark.css" rel="stylesheet" />
    <script src="//Microsoft.WinJS.2.0/js/base.js"></script>
    <script src="//Microsoft.WinJS.2.0/js/ui.js"></script>

    <!-- patient_desktop_client references -->
    <link href="/css/default.css" rel="stylesheet" />
    <script src="/js/default.js"></script>
    <script src="/js/kinect_data_extractor.js"></script>
</head>
<body>
    <h1 id="debug">Content goes here</h1>

    <script src="/js/three.min.js"></script>
    <script>
        // debug msg
        var msg = document.getElementById("debug");

        // Kinect set up
        var kinect = WindowsPreview.Kinect;
        var sensor = kinect.KinectSensor.getDefault();
        var bodyFrameReader = sensor.bodyFrameSource.openReader();
        bodyFrameReader.addEventListener("framearrived", readerBodyFrameArrived);
        var bodies = new Array(sensor.bodyFrameSource.bodyCount);
        sensor.open();

        // Set up scene
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Set up lighting
        scene.add(new THREE.AmbientLight(0xaaaaaa));
        var light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(0, 0, 1000);
        scene.add(light);

        // Set up model
        var mesh;

        // Load model
        var loader = new THREE.JSONLoader();
        loader.load("models/stan-lee/stan_lee.js", createModel);

        // Array of joints
        var joints;

        function readerBodyFrameArrived(args) {
            //msg.innerHTML = "body frame has arrived!";

            var bodyFrame = args.frameReference.acquireFrame();
            if (bodyFrame == null) {
                //msg.innerHTML = "there is no body in view!";
                return;
            }

            bodyFrame.getAndRefreshBodyData(bodies);
            bodyFrame.close();

            // find a tracked body and store its joint positions
            for (i = 0; i < bodies.length; i++) {
                if (bodies[i].isTracked) {
                    //msg.innerHTML = "body is being tracked!";
                    var kinectJoints = bodies[i].joints;
                    joints = new Array();
                    for (i = 0; i < kinectJoints.size; i++) {
                        var jointPosition = kinectJoints.lookup(i).position;
                        joints.push({ x: jointPosition.x, y: jointPosition.y, z: jointPosition.z });
                    }

                    break;
                } else {
                    //msg.innerHTML = "no body is being tracked!";
                }
            }
        }

        // some initial values
        var initQ; // initial quaternion
        var initDv; // initial direction vector

        function createModel(geometry, materials) {
            msg.innerHTML = "Called create model.";

            for (i = 0; i < materials.length; i++) {
                materials[i].skinning = true;
            }

            mesh = new THREE.SkinnedMesh(geometry, new THREE.MeshFaceMaterial(materials));
            mesh.position.set(0, -2, -5);
            mesh.scale.set(1, 1, 1);

            scene.add(mesh);

            // set initial values
            initQ = new THREE.Quaternion(mesh.skeleton.bones[1].x, mesh.skeleton.bones[1].y, mesh.skeleton.bones[1].z, mesh.skeleton.bones[1].w); // copy vals

            var x1 = mesh.skeleton.bones[0].position.x;
            var y1 = mesh.skeleton.bones[0].position.z;
            var z1 = mesh.skeleton.bones[0].position.y;

            var x2 = mesh.skeleton.bones[1].position.x;
            var y2 = mesh.skeleton.bones[1].position.z;
            var z2 = mesh.skeleton.bones[1].position.y;

            initDv = getDirectionVector(new THREE.Vector3(x1, y1, z1), new THREE.Vector3(x2, y2, z2));
            initDv.normalize();
        }

        // returns the global position of a given bone
        function getGlobalBonePosition(bone) {
            if (mesh == null) {
                return null;
            }

            mesh.updateMatrixWorld(true);
            var meshGlobal = new THREE.Vector3().setFromMatrixPosition(mesh.matrixWorld);

            return new THREE.Vector3().setFromMatrixPosition(bone.matrixWorld);
        }

        function getDirectionVector(vec1, vec2) {
            var res = new THREE.Vector3();
            res.subVectors(vec2, vec1);
            return res;
        }
        
        function render() {
            requestAnimationFrame(render);

            // map inner representation of joints to model bones
            if (mesh != null && joints != null) {
                msg.innerHTML = "Mapping joints to model.";

                // calculate target vector
                var tv = getDirectionVector(
                    new THREE.Vector3(joints[0].x, joints[0].y, -joints[0].z),
                    new THREE.Vector3(joints[1].x, joints[1].y, -joints[1].z));
                tv.normalize();

                // axis
                var axis = new THREE.Vector3().crossVectors(initDv, tv);
                axis.normalize();

                // angle
                var angle = initDv.angleTo(tv);

                // quaternion
                var s = Math.sin(angle / 2);
                var w = Math.cos(angle / 2);
                var x = axis.x * s;
                var y = axis.y * s;
                var z = axis.z * s;
                var quat = new THREE.Quaternion(x, y, z, w);
                quat.normalize();

                // apply rotation
                mesh.skeleton.bones[0].quaternion.w = quat.w;
                mesh.skeleton.bones[0].quaternion.x = quat.x;
                mesh.skeleton.bones[0].quaternion.y = quat.y;
                mesh.skeleton.bones[0].quaternion.z = quat.z;
            } else {
                msg.innerHTML = "The joints array is empty!";
            }

            renderer.render(scene, camera);
        }
        render();

    </script>
</body>
</html>
